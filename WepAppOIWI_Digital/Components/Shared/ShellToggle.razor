@rendermode InteractiveServer
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject NavigationManager Nav

<button type="button"
        class="shell-fab @(collapsed ? "is-collapsed" : "is-open")"
        title="@(collapsed ? "Open menu" : "Close menu")"
        aria-label="Toggle menu"
        aria-pressed="@(!collapsed)"
        @onclick="Toggle">
    @if (collapsed)
    {
        <!-- เมนูถูกพับอยู่: แสดงไอคอน 'list' เพื่อสื่อว่า “กดเพื่อเปิดเมนู” -->
        <i class="bi bi-list shell-fab__icon" aria-hidden="true"></i>
    }
    else
    {
        <!-- เมนูเปิดอยู่: แสดงไอคอน ‘chevron-left’ เพื่อสื่อว่า “กดเพื่อพับเมนู” -->
        <i class="bi bi-chevron-left shell-fab__icon" aria-hidden="true"></i>
    }
</button>

@code {
    private bool collapsed = true;
    private DotNetObjectReference<ShellToggle>? _selfRef;

    protected override void OnInitialized()
    {
        Nav.LocationChanged += HandleLocationChanged;
    }

    private async void HandleLocationChanged(object? sender, Microsoft.AspNetCore.Components.Routing.LocationChangedEventArgs e)
    {
        collapsed = true;
        try { await JS.InvokeVoidAsync("shellToggle.setCollapsed", true); } catch { }
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        collapsed = true;
        await JS.InvokeVoidAsync("shellToggle.setCollapsed", true);

        _selfRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("shellToggle.watch", _selfRef);
        StateHasChanged();
    }

    private async Task Toggle()
    {
        collapsed = !collapsed;
        await JS.InvokeVoidAsync("shellToggle.setCollapsed", collapsed);
    }

    [JSInvokable]
    public Task OnShellStateChanged(bool isCollapsed)
    {
        collapsed = isCollapsed;
        StateHasChanged();
        return Task.CompletedTask;
    }

    public void Dispose()
    {
        Nav.LocationChanged -= HandleLocationChanged;
        _selfRef?.Dispose();
    }
}
