@page "/documents/viewer/{Token}"
@rendermode InteractiveServer
@using System
@using System.Linq
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject DocumentCatalogService DocumentCatalog
@inject NavigationManager Navigation
@inject ILogger<WepAppOIWI_Digital.Components.Pages.DocumentViewer> Logger
@inject IJSRuntime JSRuntime

<PageTitle>‡∏î‡∏π‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ OI/WI</PageTitle>

<h1 class="mb-3">üëÅÔ∏è‚Äçüó®Ô∏è ‡∏î‡∏π‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ OI/WI</h1>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger" role="alert">@errorMessage</div>
}
else if (isLoading)
{
    <p class="text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...</p>
}
else if (document is null || fileHandle is null)
{
    <div class="alert alert-warning" role="alert">‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á</div>
}
else
{
    <div class="card mb-3 shadow-sm">
        <div class="card-body">
            <div class="d-flex justify-content-between flex-wrap gap-2">
                <div>
                    <h2 class="card-title h4 mb-1">@document.DisplayName</h2>
                    <p class="card-subtitle text-muted small mb-0">‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: @FormatTimestamp(document.UpdatedAt)</p>
                </div>
                <div class="d-flex flex-wrap gap-2">
                    <a class="btn btn-primary" href="@(downloadSource ?? "#")" target="_blank" rel="noopener" download="@fileHandle?.FileName">
                        ‚¨áÔ∏è ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå
                    </a>
                    <button type="button" class="btn btn-secondary" @onclick="NavigateHome">
                        ‚¨ÖÔ∏è ‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å
                    </button>
                </div>
            </div>
            <hr />
            <dl class="row mb-0">
                <dt class="col-sm-3">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.DocumentType)</dd>
                <dt class="col-sm-3">‡πÄ‡∏•‡∏Ç‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.DocumentCode)</dd>
                <dt class="col-sm-3">Line</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Line)</dd>
                <dt class="col-sm-3">Station</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Station)</dd>
                <dt class="col-sm-3">Model</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Model)</dd>
                <dt class="col-sm-3">Machine name</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Machine)</dd>
                <dt class="col-sm-3">‡∏ú‡∏π‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.UploadedBy)</dd>
                <dt class="col-sm-3">Comment</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Comment)</dd>
                <dt class="col-sm-3">Stamp info</dt>
                <dd class="col-sm-9">
                    @if (document.StampMode != StampMode.None)
                    {
                        <span class="badge rounded-pill bg-danger stamp-badge">@FormatStampInfo(document.StampMode, document.StampDate)</span>
                    }
                    else
                    {
                        <span>-</span>
                    }
                </dd>
                <dt class="col-sm-3">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå</dt>
                <dd class="col-sm-9">@fileHandle.ContentType</dd>
            </dl>
        </div>
    </div>

    @if (canPreviewInline && !string.IsNullOrEmpty(previewSource))
    {
        <div id="@fullScreenHostId"
             @ref="fullScreenOverlayRef"
             tabindex="-1"
             @onkeydown="HandleFullScreenKeyDown"
             @onkeydown:preventDefault="ShouldPreventFullScreenKeyHandling"
             class="@GetPreviewFrameClasses()">
            <div id="@fullScreenCanvasId" class="document-viewer">
                <!-- PDF Toolbar -->
                <div class="document-toolbar d-flex align-items-center gap-2 p-2 border-bottom bg-light">
                    <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomOut" aria-label="‡∏ã‡∏π‡∏°‡∏≠‡∏≠‡∏Å">‚àí</button>
                    <span id="@($"{pdfContainerId}-scale")" class="small">100%</span>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomIn" aria-label="‡∏ã‡∏π‡∏°‡πÄ‡∏Ç‡πâ‡∏≤">+</button>
                    <button class="btn btn-sm btn-outline-secondary ms-2" @onclick="FitWidth" aria-label="‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á">Fit width</button>
                    <button class="btn btn-sm btn-outline-secondary ms-auto" @onclick="ToggleFullScreen"
                            aria-label="@FullScreenButtonLabel" title="@FullScreenButtonLabel">
                        <i class="bi @(isFullScreen ? "bi-fullscreen-exit" : "bi-arrows-fullscreen")"></i>
                    </button>
                </div>

                @if (fullScreenRenderFailed)
                {
                    <div class="alert alert-warning pdf-fullscreen-error" role="alert">
                        ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÑ‡∏î‡πâ ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏≠‡∏≤‡∏à‡∏õ‡∏¥‡∏î‡∏Å‡∏±‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
                    </div>
                }

                <!-- PDF Canvas Container -->
                <div class="document-container position-relative">
                    @if (isPreviewLoading)
                    {
                        <div class="pdf-preview-status text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ PDF...</div>
                    }
                    else if (!string.IsNullOrEmpty(previewErrorMessage))
                    {
                        <div class="pdf-preview-status alert alert-warning" role="alert">@previewErrorMessage</div>
                    }

                    <div id="@pdfContainerId" class="pdfjs-viewer"></div>
                </div>

                @if (isFullScreen && HasPageControls)
                {
                    <div class="pdf-fullscreen-nav">
                        <button class="btn btn-lg btn-outline-light" @onclick="PreviousPage" disabled="@(!CanGoPrevious)" aria-label="‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤">
                            <i class="bi bi-arrow-left"></i>
                        </button>
                        <span class="pdf-fullscreen-page-indicator">‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà @currentPage / @totalPages</span>
                        <button class="btn btn-lg btn-outline-light" @onclick="NextPage" disabled="@(!CanGoNext)" aria-label="‡∏´‡∏ô‡πâ‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ">
                            <i class="bi bi-arrow-right"></i>
                        </button>
                    </div>
                }
            </div>
        </div>

        <p class="text-muted small mt-2">
            ‡∏´‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
        </p>
        if (isFullScreen)
        {
            <div class="pdf-fullscreen-overlay" tabindex="0" @onkeydown="HandleFullScreenKeyDown" @ref="fullScreenOverlayRef">
                <div class="pdf-fullscreen-toolbar d-flex align-items-center justify-content-between">
                    <div class="pdf-fullscreen-title text-truncate" title="@document?.DisplayName">@document?.DisplayName</div>
                    <button class="btn btn-sm btn-light" @onclick="ExitFullScreen" aria-label="‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠" title="‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
                <div class="pdf-fullscreen-body">
                    <div class="pdf-fullscreen-canvas-wrapper">
                        @if (fullScreenRenderFailed)
                        {
                            <iframe src="@previewSource" class="pdf-fullscreen-iframe" title="‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠"></iframe>
                        }
                        else
                        {
                            <canvas id="@fullScreenCanvasId" class="pdf-fullscreen-canvas"></canvas>
                        }
                    </div>
                </div>
                @if (HasPageControls)
                {
                    <div class="pdf-fullscreen-nav">
                        <button class="btn btn-lg btn-outline-light" @onclick="PreviousPage" disabled="@(!CanGoPrevious)" aria-label="‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤">
                            <i class="bi bi-arrow-left"></i>
                        </button>
                        <span class="pdf-fullscreen-page-indicator">‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà @currentPage / @totalPages</span>
                        <button class="btn btn-lg btn-outline-light" @onclick="NextPage" disabled="@(!CanGoNext)" aria-label="‡∏´‡∏ô‡πâ‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ">
                            <i class="bi bi-arrow-right"></i>
                        </button>
                    </div>
                }
            </div>
        }
    }
    else
    {
        <div class="alert alert-info" role="alert">
            ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
        </div>
    }
}

@implements IAsyncDisposable

@code {
    [Parameter] public string Token { get; set; } = string.Empty;

    private bool isLoading = true;
    private string? errorMessage;
    private DocumentRecord? document;
    private DocumentCatalogService.DocumentFileHandle? fileHandle;
    private string? previewSource;
    private string? downloadSource;
    private bool canPreviewInline;
    private bool pendingPdfRender;
    private int pdfRenderAttempts;
    private bool isPreviewLoading;
    private string? previewErrorMessage;
    private readonly string pdfContainerId = $"pdfjs-viewer-{System.Guid.NewGuid():N}";
    private readonly string fullScreenHostId = $"pdf-viewer-host-{System.Guid.NewGuid():N}";
    private readonly string fullScreenCanvasId = $"pdf-viewer-focus-{System.Guid.NewGuid():N}";
    private const int MaxPdfRenderAttempts = 3;
    private ElementReference fullScreenOverlayRef;
    private bool isFullScreen;
    private bool hasPageData;
    private int totalPages = 1;
    private int currentPage = 1;
    private bool isPdfReady;
    private bool fullScreenInteropInitialized;
    private bool requestFullScreenPending;
    private bool exitFullScreenPending;
    private bool fullScreenRenderFailed;
    private DotNetObjectReference<DocumentViewer>? dotNetRef;

    private bool ShouldPreventFullScreenKeyHandling => isFullScreen;

    protected override async Task OnParametersSetAsync()
    {
        var wasFullScreen = isFullScreen;

        isLoading = true;
        errorMessage = null;
        document = null;
        fileHandle = null;
        previewSource = null;
        downloadSource = null;
        canPreviewInline = false;
        pendingPdfRender = false;
        pdfRenderAttempts = 0;
        hasPageData = false;
        totalPages = 1;
        currentPage = 1;
        isPdfReady = false;
        isPreviewLoading = true;
        previewErrorMessage = null;
        requestFullScreenPending = false;
        exitFullScreenPending = wasFullScreen;
        isFullScreen = false;
        fullScreenRenderFailed = false;

        if (!DocumentCatalogService.TryDecodeDocumentToken(Token, out var normalizedPath))
        {
            errorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ";
            isLoading = false;
            return;
        }

        try
        {
            document = await DocumentCatalog.TryGetDocumentAsync(normalizedPath);
            if (document is null)
            {
                errorMessage = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏π";
                return;
            }

            fileHandle = await DocumentCatalog.TryGetDocumentFileAsync(normalizedPath);
            if (fileHandle is null)
            {
                errorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ";
                return;
            }

            var cacheBust = (document?.UpdatedAt?.UtcTicks ?? DateTimeOffset.UtcNow.UtcTicks).ToString();
            previewSource = $"/documents/preview/{Uri.EscapeDataString(Token)}?v={cacheBust}";
            downloadSource = $"/documents/download/{Uri.EscapeDataString(Token)}?v={cacheBust}";
            canPreviewInline = string.Equals(fileHandle.ContentType, "application/pdf", StringComparison.OrdinalIgnoreCase);
            pendingPdfRender = canPreviewInline && !string.IsNullOrEmpty(previewSource);
            pdfRenderAttempts = 0;
            isPreviewLoading = pendingPdfRender;
        }
        catch (OperationCanceledException)
        {
            errorMessage = "‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to open document '{DocumentPath}'", normalizedPath);
            errorMessage = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á";
        }
        finally
        {
            isLoading = false;
            if (!pendingPdfRender)
            {
                isPreviewLoading = false;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!fullScreenInteropInitialized && canPreviewInline && !string.IsNullOrEmpty(previewSource))
        {
            dotNetRef ??= DotNetObjectReference.Create(this);
            try
            {
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.initializeFullScreen", dotNetRef, fullScreenHostId, pdfContainerId);
                fullScreenInteropInitialized = true;
            }
            catch (JSException jsEx)
            {
                Logger.LogWarning(jsEx, "Failed to initialize PDF fullscreen helpers for '{DocumentPath}'", document?.FileName);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Unexpected error while initializing PDF fullscreen helpers for '{DocumentPath}'", document?.FileName);
            }
        }

        if (!isLoading && pendingPdfRender && !string.IsNullOrEmpty(previewSource))
        {
            pendingPdfRender = false;
            try
            {
                pdfRenderAttempts++;
                previewErrorMessage = null;
                isPreviewLoading = true;
                isPdfReady = false;
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.ready");
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.render", previewSource!, pdfContainerId);
                if (isFullScreen && HasPageControls)
                {
                    await ScrollToCurrentPageAsync(false);
                }
            }
            catch (JSException jsEx)
            {
                Logger.LogError(jsEx, "Failed to render PDF preview for '{DocumentPath}'", document?.FileName);
                if (pdfRenderAttempts < MaxPdfRenderAttempts)
                {
                    pendingPdfRender = true;
                    await InvokeAsync(StateHasChanged);
                }
                else
                {
                    isPreviewLoading = false;
                    previewErrorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå PDF ‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ó‡∏ô";
                    await InvokeAsync(StateHasChanged);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Unexpected error while rendering PDF preview for '{DocumentPath}'", document?.FileName);
                if (pdfRenderAttempts < MaxPdfRenderAttempts)
                {
                    pendingPdfRender = true;
                    await InvokeAsync(StateHasChanged);
                }
                else
                {
                    isPreviewLoading = false;
                    previewErrorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå PDF ‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ó‡∏ô";
                    await InvokeAsync(StateHasChanged);
                }
            }
        }

        if (requestFullScreenPending)
        {
            requestFullScreenPending = false;
            try
            {
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.requestFullScreen", fullScreenHostId);
            }
            catch (JSException jsEx)
            {
                Logger.LogWarning(jsEx, "Browser refused fullscreen for '{DocumentPath}'", document?.FileName);
                fullScreenRenderFailed = true;
                isFullScreen = false;
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Unexpected error while requesting fullscreen for '{DocumentPath}'", document?.FileName);
                fullScreenRenderFailed = true;
                isFullScreen = false;
                await InvokeAsync(StateHasChanged);
            }
        }

        if (exitFullScreenPending)
        {
            exitFullScreenPending = false;
            await JSRuntime.InvokeVoidAsync("pdfViewerInterop.exitFullScreen", fullScreenHostId);
        }
    }

    private async Task ZoomIn()
    {
        await JSRuntime.InvokeVoidAsync("pdfViewerInterop.zoomIn", pdfContainerId);
    }

    private async Task ZoomOut()
    {
        await JSRuntime.InvokeVoidAsync("pdfViewerInterop.zoomOut", pdfContainerId);
    }

    private async Task FitWidth()
    {
        await JSRuntime.InvokeVoidAsync("pdfViewerInterop.fitWidth", pdfContainerId);
    }

    private string FullScreenButtonLabel => isFullScreen ? "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠" : "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠";
    private bool HasPageControls => isPdfReady && hasPageData && totalPages > 1;
    private bool CanGoNext => HasPageControls && currentPage < totalPages;
    private bool CanGoPrevious => HasPageControls && currentPage > 1;

    private Task ToggleFullScreen()
        => isFullScreen ? ExitFullScreenAsync() : EnterFullScreenAsync();

    private async Task EnterFullScreenAsync()
    {
        fullScreenRenderFailed = false;
        try
        {
            totalPages = await JSRuntime.InvokeAsync<int>("pdfViewerInterop.getPageCount", pdfContainerId);
            hasPageData = totalPages > 0;
            if (!hasPageData)
            {
                totalPages = 1;
            }
        }
        catch (JSException jsEx)
        {
            Logger.LogWarning(jsEx, "Unable to determine PDF page count for '{DocumentPath}' in full screen", document?.FileName);
            hasPageData = false;
            totalPages = 1;
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Unexpected error determining PDF page count for '{DocumentPath}'", document?.FileName);
            hasPageData = false;
            totalPages = 1;
        }

        if (hasPageData)
        {
            try
            {
                var visiblePage = await JSRuntime.InvokeAsync<int>("pdfViewerInterop.getCurrentPageIndex", pdfContainerId);
                if (visiblePage > 0)
                {
                    currentPage = Math.Clamp(visiblePage, 1, totalPages);
                }
            }
            catch (JSException jsEx)
            {
                Logger.LogDebug(jsEx, "Unable to determine current visible page for '{DocumentPath}'");
                currentPage = Math.Clamp(currentPage, 1, totalPages);
            }
            catch (Exception ex)
            {
                Logger.LogDebug(ex, "Unexpected error determining current visible page for '{DocumentPath}'");
                currentPage = Math.Clamp(currentPage, 1, totalPages);
            }
        }
        else
        {
            currentPage = 1;
        }

        requestFullScreenPending = true;
        await InvokeAsync(StateHasChanged);
    }

    private Task ExitFullScreenAsync()
    {
        fullScreenRenderFailed = false;
        exitFullScreenPending = true;
        return InvokeAsync(StateHasChanged);
    }

    private Task ExitFullScreen() => ExitFullScreenAsync();

    private async Task NextPage() => await ChangePageAsync(1);
    private async Task PreviousPage() => await ChangePageAsync(-1);

    private async Task ChangePageAsync(int delta)
    {
        if (!HasPageControls)
        {
            return;
        }

        var newPage = Math.Clamp(currentPage + delta, 1, totalPages);
        if (newPage == currentPage)
        {
            return;
        }

        currentPage = newPage;
        await ScrollToCurrentPageAsync();
        await FocusFullScreenHostAsync();
        await InvokeAsync(StateHasChanged);
    }

    private Task ScrollToCurrentPageAsync(bool smooth = true)
    {
        if (!isPdfReady || !HasPageControls)
        {
            return Task.CompletedTask;
        }

        return InvokeViewerVoidAsync("goToPage", pdfContainerId, currentPage, smooth);
    }

    private async Task HandleFullScreenKeyDown(KeyboardEventArgs args)
    {
        if (!isFullScreen)
        {
            return;
        }

        switch (args.Key)
        {
            case "ArrowRight":
            case "PageDown":
            case " ":
            case "Spacebar":
                await NextPage();
                break;
            case "ArrowLeft":
            case "PageUp":
            case "Backspace":
                await PreviousPage();
                break;
            case "Escape":
                await ExitFullScreenAsync();
                break;
        }
    }

    private async Task FocusFullScreenHostAsync()
    {
        if (!isFullScreen)
        {
            return;
        }

        try
        {
            if (fullScreenOverlayRef.Context is not null)
            {
                await fullScreenOverlayRef.FocusAsync();
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.focusFullScreenHost", fullScreenHostId);
            }
        }
        catch (JSException jsEx)
        {
            Logger.LogDebug(jsEx, "Unable to focus fullscreen host for '{DocumentPath}'", document?.FileName);
        }
        catch (InvalidOperationException invalidOp)
        {
            Logger.LogDebug(invalidOp, "Unable to focus fullscreen host for '{DocumentPath}'", document?.FileName);
        }
    }

    [JSInvokable(nameof(HandleFullScreenCommandFromJsAsync))]
    public Task HandleFullScreenCommandFromJsAsync(string command) => command switch
    {
        "next" => NextPage(),
        "previous" => PreviousPage(),
        "exit" => ExitFullScreenAsync(),
        _ => Task.CompletedTask
    };

    [JSInvokable(nameof(OnFullScreenChangedFromJsAsync))]
    public async Task OnFullScreenChangedFromJsAsync(string hostId, bool active)
    {
        if (!string.Equals(hostId, fullScreenHostId, StringComparison.Ordinal))
        {
            return;
        }

        if (isFullScreen == active)
        {
            return;
        }

        fullScreenRenderFailed = false;
        isFullScreen = active;

        if (isFullScreen && HasPageControls)
        {
            await ScrollToCurrentPageAsync(false);
        }

        if (isFullScreen)
        {
            await FocusFullScreenHostAsync();
        }

        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable(nameof(OnPdfRenderStatusChangedFromJsAsync))]
    public Task OnPdfRenderStatusChangedFromJsAsync(string viewerId, bool success, string? message)
    {
        if (!string.Equals(viewerId, pdfContainerId, StringComparison.Ordinal))
        {
            return Task.CompletedTask;
        }

        isPreviewLoading = false;
        isPdfReady = success;
        previewErrorMessage = success ? null : (string.IsNullOrWhiteSpace(message)
            ? "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå PDF ‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏Å‡∏î‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ó‡∏ô"
            : message);

        return InvokeAsync(StateHasChanged);
    }

    private string GetPreviewFrameClasses()
        => isFullScreen
            ? "document-preview-frame border rounded pdf-fullscreen-active"
            : "document-preview-frame border rounded";

    private static string DisplayOrDash(string? value)
        => string.IsNullOrWhiteSpace(value) || value == "-" ? "-" : value!;

    private static string FormatTimestamp(DateTimeOffset? timestamp)
        => timestamp.HasValue
            ? timestamp.Value.ToLocalTime().ToString("yyyy-MM-dd HH:mm:ss")
            : "-";

    private static string FormatStampInfo(StampMode mode, DateOnly? date)
        => StampDisplay.GetDisplayText(mode, date);

    private void NavigateHome() => Navigation.NavigateTo("/");

    public async ValueTask DisposeAsync()
    {
        if (fullScreenInteropInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.disposeFullScreen", fullScreenHostId);
            }
            catch (JSException)
            {
            }
            catch (ObjectDisposedException)
            {
            }
            catch (InvalidOperationException)
            {
            }
        }

        dotNetRef?.Dispose();
    }

    private async Task InvokeViewerVoidAsync(string identifier, params object?[] args)
    {
        await JSRuntime.InvokeVoidAsync($"pdfViewerInterop.{identifier}", args);
    }
}
