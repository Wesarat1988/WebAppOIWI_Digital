@page "/documents/viewer/{Token}"
@rendermode InteractiveServer
@using System
@using System.Linq
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject DocumentCatalogService DocumentCatalog
@inject NavigationManager Navigation
@inject ILogger<WepAppOIWI_Digital.Components.Pages.DocumentViewer> Logger
@inject IJSRuntime JSRuntime

<PageTitle>‡∏î‡∏π‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ OI/WI</PageTitle>

<h1 class="mb-3">üëÅÔ∏è‚Äçüó®Ô∏è ‡∏î‡∏π‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ OI/WI</h1>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger" role="alert">@errorMessage</div>
}
else if (isLoading)
{
    <p class="text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...</p>
}
else if (document is null || fileHandle is null)
{
    <div class="alert alert-warning" role="alert">‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á</div>
}
else
{
    <div class="card mb-3 shadow-sm">
        <div class="card-body">
            <div class="d-flex justify-content-between flex-wrap gap-2">
                <div>
                    <h2 class="card-title h4 mb-1">@document.DisplayName</h2>
                    <p class="card-subtitle text-muted small mb-0">‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: @FormatTimestamp(document.UpdatedAt)</p>
                </div>
                <div class="d-flex flex-wrap gap-2">
                    <a class="btn btn-primary" href="@(downloadSource ?? "#")" target="_blank" rel="noopener" download="@fileHandle?.FileName">
                        ‚¨áÔ∏è ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå
                    </a>
                    <button type="button" class="btn btn-secondary" @onclick="NavigateHome">
                        ‚¨ÖÔ∏è ‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å
                    </button>
                </div>
            </div>
            <hr />
            <dl class="row mb-0">
                <dt class="col-sm-3">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.DocumentType)</dd>
                <dt class="col-sm-3">‡πÄ‡∏•‡∏Ç‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.DocumentCode)</dd>
                <dt class="col-sm-3">Line</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Line)</dd>
                <dt class="col-sm-3">Station</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Station)</dd>
                <dt class="col-sm-3">Model</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Model)</dd>
                <dt class="col-sm-3">Machine name</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Machine)</dd>
                <dt class="col-sm-3">‡∏ú‡∏π‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.UploadedBy)</dd>
                <dt class="col-sm-3">Comment</dt>
                <dd class="col-sm-9">@DisplayOrDash(document.Comment)</dd>
                <dt class="col-sm-3">Stamp info</dt>
                <dd class="col-sm-9">
                    @if (document.StampMode != StampMode.None)
                    {
                        <span class="badge rounded-pill bg-danger stamp-badge">@FormatStampInfo(document.StampMode, document.StampDate)</span>
                    }
                    else
                    {
                        <span>-</span>
                    }
                </dd>
                <dt class="col-sm-3">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå</dt>
                <dd class="col-sm-9">@fileHandle.ContentType</dd>
            </dl>
        </div>
    </div>

    @if (canPreviewInline && !string.IsNullOrEmpty(previewSource))
    {
        <div id="@fullScreenHostId"
             @ref="fullScreenOverlayRef"
             tabindex="-1"
             @onkeydown="HandleFullScreenKeyDown"
             @onkeydown:preventDefault="ShouldPreventFullScreenKeyHandling"
             role="@(IsFullScreen ? "dialog" : null)"
             aria-modal="@(IsFullScreen ? "true" : null)"
             class="@GetPreviewFrameClasses()">
            <div class="document-viewer @(IsFullScreen ? "pdf-fullscreen-content" : string.Empty)">
                @if (!IsFullScreen)
                {
                    <div class="document-toolbar d-flex align-items-center gap-2 p-2 border-bottom bg-light">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomOut" aria-label="‡∏ã‡∏π‡∏°‡∏≠‡∏≠‡∏Å">‚àí</button>
                        <span id="@($"{pdfContainerId}-scale")" class="small">100%</span>
                        <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomIn" aria-label="‡∏ã‡∏π‡∏°‡πÄ‡∏Ç‡πâ‡∏≤">+</button>
                        <button class="btn btn-sm btn-outline-secondary ms-2" @onclick="FitWidth" aria-label="‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á">Fit width</button>
                        <button class="btn btn-sm btn-outline-secondary ms-auto" @onclick="ToggleFullScreen"
                                aria-label="@FullScreenButtonLabel" title="@FullScreenButtonLabel">
                            <i class="bi bi-arrows-fullscreen"></i>
                        </button>
                    </div>
                }
                else
                {
                    <!-- Fullscreen overlay toolbar rendered when the viewer is expanded in-page -->
                    <div class="pdf-fullscreen-toolbar" role="toolbar" aria-label="‡∏ï‡∏±‡∏ß‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠">
                        <div class="pdf-fullscreen-toolbar-left d-flex align-items-center gap-2">
                            <button class="btn btn-sm btn-light" @onclick="ZoomOut" aria-label="‡∏ã‡∏π‡∏°‡∏≠‡∏≠‡∏Å">‚àí</button>
                            <span id="@($"{pdfContainerId}-scale")" class="small text-white">100%</span>
                            <button class="btn btn-sm btn-light" @onclick="ZoomIn" aria-label="‡∏ã‡∏π‡∏°‡πÄ‡∏Ç‡πâ‡∏≤">+</button>
                            <button class="btn btn-sm btn-light" @onclick="FitWidth" aria-label="‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á">Fit width</button>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <span class="pdf-fullscreen-title text-truncate" title="@document?.DisplayName">@document?.DisplayName</span>
                            <button class="btn btn-sm btn-light" @onclick="ExitFullScreen" aria-label="‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠" title="‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠">
                                <i class="bi bi-x-lg"></i>
                            </button>
                        </div>
                    </div>
                }

                <div class="document-container position-relative @(IsFullScreen ? "pdf-fullscreen-frame-container" : string.Empty)"
                     @ref="pdfScrollContainerRef"
                     @onscroll="HandlePdfScroll">
                    @if (isPreviewLoading)
                    {
                        <div class="pdf-preview-status text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ PDF...</div>
                    }
                    else if (!string.IsNullOrEmpty(previewErrorMessage))
                    {
                        <div class="pdf-preview-status alert alert-warning" role="alert">@previewErrorMessage</div>
                    }

                    <div id="@pdfContainerId" class="pdfjs-viewer"></div>
                </div>

                @if (IsFullScreen && HasPageControls)
                {
                    <div class="pdf-fullscreen-nav">
                        <button class="btn btn-lg btn-outline-light" @onclick="PreviousPage" disabled="@(!CanGoPrevious)" aria-label="‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤">
                            <i class="bi bi-arrow-left"></i>
                        </button>
                        <span class="pdf-fullscreen-page-indicator">‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà @currentPage / @totalPages</span>
                        <button class="btn btn-lg btn-outline-light" @onclick="NextPage" disabled="@(!CanGoNext)" aria-label="‡∏´‡∏ô‡πâ‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ">
                            <i class="bi bi-arrow-right"></i>
                        </button>
                    </div>
                }
            </div>
        </div>

        <p class="text-muted small mt-2">
            ‡∏´‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
        </p>
    }
    else
    {
        <div class="alert alert-info" role="alert">
            ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
        </div>
    }
}

@implements IAsyncDisposable

@code {
    [Parameter] public string Token { get; set; } = string.Empty;

    private bool isLoading = true;
    private string? errorMessage;
    private DocumentRecord? document;
    private DocumentCatalogService.DocumentFileHandle? fileHandle;
    private string? previewSource;
    private string? downloadSource;
    private bool canPreviewInline;
    private bool pendingPdfRender;
    private int pdfRenderAttempts;
    private bool isPreviewLoading;
    private string? previewErrorMessage;
    private readonly string pdfContainerId = $"pdfjs-viewer-{System.Guid.NewGuid():N}";
    private readonly string fullScreenHostId = $"pdf-viewer-host-{System.Guid.NewGuid():N}";
    private const int MaxPdfRenderAttempts = 3;
    private ElementReference fullScreenOverlayRef;
    private ElementReference pdfScrollContainerRef;
    private bool focusOverlayPending;
    private bool IsFullScreen { get; set; }
    private bool viewerRegistrationCompleted;
    private bool hasPageData;
    private int totalPages = 1;
    private int currentPage = 1;
    private bool isPdfReady;
    private bool isUpdatingVisiblePage;
    private DotNetObjectReference<DocumentViewer>? dotNetRef;

    private const string PdfPageSelector = ".pdfjs-page-canvas";

    private bool ShouldPreventFullScreenKeyHandling => IsFullScreen;

    protected override async Task OnParametersSetAsync()
    {
        isLoading = true;
        errorMessage = null;
        document = null;
        fileHandle = null;
        previewSource = null;
        downloadSource = null;
        canPreviewInline = false;
        pendingPdfRender = false;
        pdfRenderAttempts = 0;
        hasPageData = false;
        totalPages = 1;
        currentPage = 1;
        isPdfReady = false;
        isPreviewLoading = true;
        previewErrorMessage = null;
        focusOverlayPending = false;
        IsFullScreen = false;

        if (!DocumentCatalogService.TryDecodeDocumentToken(Token, out var normalizedPath))
        {
            errorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ";
            isLoading = false;
            return;
        }

        try
        {
            document = await DocumentCatalog.TryGetDocumentAsync(normalizedPath);
            if (document is null)
            {
                errorMessage = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏π";
                return;
            }

            fileHandle = await DocumentCatalog.TryGetDocumentFileAsync(normalizedPath);
            if (fileHandle is null)
            {
                errorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ";
                return;
            }

            var cacheBust = (document?.UpdatedAt?.UtcTicks ?? DateTimeOffset.UtcNow.UtcTicks).ToString();
            previewSource = $"/documents/preview/{Uri.EscapeDataString(Token)}?v={cacheBust}";
            downloadSource = $"/documents/download/{Uri.EscapeDataString(Token)}?v={cacheBust}";
            canPreviewInline = string.Equals(fileHandle.ContentType, "application/pdf", StringComparison.OrdinalIgnoreCase);
            pendingPdfRender = canPreviewInline && !string.IsNullOrEmpty(previewSource);
            pdfRenderAttempts = 0;
            isPreviewLoading = pendingPdfRender;
        }
        catch (OperationCanceledException)
        {
            errorMessage = "‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to open document '{DocumentPath}'", normalizedPath);
            errorMessage = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á";
        }
        finally
        {
            isLoading = false;
            if (!pendingPdfRender)
            {
                isPreviewLoading = false;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !viewerRegistrationCompleted && canPreviewInline && !string.IsNullOrEmpty(previewSource))
        {
            dotNetRef ??= DotNetObjectReference.Create(this);
            try
            {
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.initializeFullScreen", dotNetRef, fullScreenHostId, pdfContainerId);
                viewerRegistrationCompleted = true;
            }
            catch (Exception ex)
            {
                if (ex is JSException jsEx)
                {
                    Logger.LogWarning(jsEx, "Failed to initialize PDF fullscreen helpers for '{DocumentPath}'", document?.FileName);
                }
                else
                {
                    Logger.LogWarning(ex, "Unexpected error while initializing PDF fullscreen helpers for '{DocumentPath}'", document?.FileName);
                }
            }
        }

        if (!isLoading && pendingPdfRender && !string.IsNullOrEmpty(previewSource))
        {
            pendingPdfRender = false;
            try
            {
                pdfRenderAttempts++;
                previewErrorMessage = null;
                isPreviewLoading = true;
                isPdfReady = false;
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.ready");
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.render", previewSource!, pdfContainerId);
                if (IsFullScreen && HasPageControls)
                {
                    await ScrollToCurrentPageAsync(false);
                }
            }
            catch (Exception ex)
            {
                if (ex is JSException jsEx)
                {
                    Logger.LogError(jsEx, "Failed to render PDF preview for '{DocumentPath}'", document?.FileName);
                }
                else
                {
                    Logger.LogError(ex, "Unexpected error while rendering PDF preview for '{DocumentPath}'", document?.FileName);
                }
                if (pdfRenderAttempts < MaxPdfRenderAttempts)
                {
                    pendingPdfRender = true;
                    await InvokeAsync(StateHasChanged);
                }
                else
                {
                    isPreviewLoading = false;
                    previewErrorMessage = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå PDF ‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ó‡∏ô";
                    await InvokeAsync(StateHasChanged);
                }
            }
        }

        if (focusOverlayPending && IsFullScreen)
        {
            focusOverlayPending = false;
            await FocusFullScreenHostAsync();
        }
    }

    private async Task ZoomIn()
    {
        await JSRuntime.InvokeVoidAsync("pdfViewerInterop.zoomIn", pdfContainerId);
    }

    private async Task ZoomOut()
    {
        await JSRuntime.InvokeVoidAsync("pdfViewerInterop.zoomOut", pdfContainerId);
    }

    private async Task FitWidth()
    {
        await JSRuntime.InvokeVoidAsync("pdfViewerInterop.fitWidth", pdfContainerId);
    }

    private string FullScreenButtonLabel => "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠";
    private bool HasPageControls => isPdfReady && hasPageData && totalPages > 1;
    private bool CanGoNext => HasPageControls && currentPage < totalPages;
    private bool CanGoPrevious => HasPageControls && currentPage > 1;

    private async Task ToggleFullScreen()
    {
        if (!IsFullScreen && string.IsNullOrEmpty(previewSource))
        {
            return;
        }

        if (IsFullScreen)
        {
            await ExitFullScreenAsync();
        }
        else
        {
            await EnterFullScreenAsync();
        }
    }

    private async Task EnterFullScreenAsync()
    {
        if (IsFullScreen)
        {
            return;
        }

        if (string.IsNullOrEmpty(previewSource))
        {
            return;
        }

        try
        {
            totalPages = await JSRuntime.InvokeAsync<int>("pdfViewerInterop.getPageCount", pdfContainerId);
            hasPageData = totalPages > 0;
            if (!hasPageData)
            {
                totalPages = 1;
            }
        }
        catch (Exception ex)
        {
            if (ex is JSException jsEx)
            {
                Logger.LogWarning(jsEx, "Unable to determine PDF page count for '{DocumentPath}' in full screen", document?.FileName);
            }
            else
            {
                Logger.LogWarning(ex, "Unexpected error determining PDF page count for '{DocumentPath}'", document?.FileName);
            }
            hasPageData = false;
            totalPages = 1;
        }

        if (hasPageData)
        {
            await UpdateVisiblePageFromScrollContainerAsync();
        }
        else
        {
            currentPage = 1;
        }

        IsFullScreen = true;
        focusOverlayPending = true;
        await InvokeAsync(StateHasChanged);
        if (HasPageControls)
        {
            await ScrollToCurrentPageAsync(false);
        }
    }

    private Task ExitFullScreenAsync()
    {
        if (!IsFullScreen)
        {
            return Task.CompletedTask;
        }

        IsFullScreen = false;
        focusOverlayPending = false;
        return InvokeAsync(StateHasChanged);
    }

    private Task ExitFullScreen() => ExitFullScreenAsync();

    private async Task NextPage() => await ChangePageAsync(1);
    private async Task PreviousPage() => await ChangePageAsync(-1);

    private async Task ChangePageAsync(int delta)
    {
        if (!HasPageControls)
        {
            return;
        }

        var newPage = Math.Clamp(currentPage + delta, 1, totalPages);
        if (newPage == currentPage)
        {
            return;
        }

        currentPage = newPage;
        await ScrollToCurrentPageAsync();
        await FocusFullScreenHostAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task ScrollToCurrentPageAsync(bool smooth = true)
    {
        if (!isPdfReady || !HasPageControls || pdfScrollContainerRef.Context is null)
        {
            return;
        }

        try
        {
            await JSRuntime.InvokeVoidAsync("pdfViewerInterop.scrollToPageInContainer",
                pdfScrollContainerRef,
                PdfPageSelector,
                currentPage,
                smooth);
        }
        catch (JSException ex)
        {
            Logger.LogDebug(ex, "Unable to scroll PDF viewer to page {Page} for '{DocumentPath}'", currentPage, document?.FileName);
        }
        catch (ObjectDisposedException ex)
        {
            Logger.LogDebug(ex, "PDF viewer was disposed before scrolling to page {Page} for '{DocumentPath}'", currentPage, document?.FileName);
        }
        catch (InvalidOperationException ex)
        {
            Logger.LogDebug(ex, "PDF viewer scroll target is unavailable for '{DocumentPath}'", document?.FileName);
        }
    }

    private async Task HandlePdfScroll()
    {
        if (!IsFullScreen || !HasPageControls || !isPdfReady || pdfScrollContainerRef.Context is null)
        {
            return;
        }

        if (isUpdatingVisiblePage)
        {
            return;
        }

        try
        {
            isUpdatingVisiblePage = true;
            var visiblePage = await JSRuntime.InvokeAsync<int>("pdfViewerInterop.getVisiblePageIndexInContainer",
                pdfScrollContainerRef,
                PdfPageSelector);

            if (visiblePage >= 1 && visiblePage <= totalPages && visiblePage != currentPage)
            {
                currentPage = visiblePage;
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (JSException ex)
        {
            Logger.LogDebug(ex, "Unable to detect visible PDF page during scroll for '{DocumentPath}'", document?.FileName);
        }
        catch (ObjectDisposedException ex)
        {
            Logger.LogDebug(ex, "PDF viewer scroll detection skipped because the component was disposed for '{DocumentPath}'", document?.FileName);
        }
        catch (InvalidOperationException ex)
        {
            Logger.LogDebug(ex, "PDF viewer scroll detection failed because the element was unavailable for '{DocumentPath}'", document?.FileName);
        }
        finally
        {
            isUpdatingVisiblePage = false;
        }
    }

    private async Task UpdateVisiblePageFromScrollContainerAsync()
    {
        if (!hasPageData || pdfScrollContainerRef.Context is null)
        {
            currentPage = Math.Clamp(currentPage, 1, totalPages);
            return;
        }

        try
        {
            var visiblePage = await JSRuntime.InvokeAsync<int>("pdfViewerInterop.getVisiblePageIndexInContainer",
                pdfScrollContainerRef,
                PdfPageSelector);

            if (visiblePage >= 1)
            {
                currentPage = Math.Clamp(visiblePage, 1, totalPages);
                return;
            }
        }
        catch (JSException ex)
        {
            Logger.LogDebug(ex, "Unable to determine current visible page for '{DocumentPath}'");
        }
        catch (ObjectDisposedException ex)
        {
            Logger.LogDebug(ex, "Visible page detection skipped because the component was disposed for '{DocumentPath}'", document?.FileName);
        }
        catch (InvalidOperationException ex)
        {
            Logger.LogDebug(ex, "Visible page detection failed because the viewer was unavailable for '{DocumentPath}'", document?.FileName);
        }

        currentPage = Math.Clamp(currentPage, 1, totalPages);
    }

    private async Task HandleFullScreenKeyDown(KeyboardEventArgs args)
    {
        if (!IsFullScreen)
        {
            return;
        }

        switch (args.Key)
        {
            case "ArrowRight":
            case "PageDown":
            case " ":
            case "Spacebar":
                await NextPage();
                break;
            case "ArrowLeft":
            case "PageUp":
            case "Backspace":
                await PreviousPage();
                break;
            case "Escape":
                await ExitFullScreenAsync();
                break;
        }
    }

    private async Task FocusFullScreenHostAsync()
    {
        if (!IsFullScreen)
        {
            return;
        }

        try
        {
            if (fullScreenOverlayRef.Context is not null)
            {
                await fullScreenOverlayRef.FocusAsync();
            }
        }
        catch (InvalidOperationException ex)
        {
            Logger.LogDebug(ex, "Unable to focus fullscreen host for '{DocumentPath}'", document?.FileName);
        }
    }

    [JSInvokable(nameof(OnPdfRenderStatusChangedFromJsAsync))]
    public Task OnPdfRenderStatusChangedFromJsAsync(string viewerId, bool success, string? message)
    {
        if (!string.Equals(viewerId, pdfContainerId, StringComparison.Ordinal))
        {
            return Task.CompletedTask;
        }

        isPreviewLoading = false;
        isPdfReady = success;
        previewErrorMessage = success ? null : (string.IsNullOrWhiteSpace(message)
            ? "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå PDF ‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏Å‡∏î‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ó‡∏ô"
            : message);

        return InvokeAsync(StateHasChanged);
    }

    private string GetPreviewFrameClasses()
        => IsFullScreen
            ? "pdf-fullscreen-overlay"
            : "document-preview-frame border rounded";

    private static string DisplayOrDash(string? value)
        => string.IsNullOrWhiteSpace(value) || value == "-" ? "-" : value!;

    private static string FormatTimestamp(DateTimeOffset? timestamp)
        => timestamp.HasValue
            ? timestamp.Value.ToLocalTime().ToString("yyyy-MM-dd HH:mm:ss")
            : "-";

    private static string FormatStampInfo(StampMode mode, DateOnly? date)
        => StampDisplay.GetDisplayText(mode, date);

    private void NavigateHome() => Navigation.NavigateTo("/");

    public async ValueTask DisposeAsync()
    {
        if (viewerRegistrationCompleted)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("pdfViewerInterop.disposeFullScreen", fullScreenHostId);
            }
            catch (JSException)
            {
            }
            catch (ObjectDisposedException)
            {
            }
            catch (InvalidOperationException)
            {
            }
        }

        dotNetRef?.Dispose();
    }

}
